# Test-Driven Development Workshop

**Product ID**: 20165
**Category ID**: nan
**Modality**: 6
**Active**: True
**Language**: en
**Product Code**: TDDWS
**Vendor Code**: CM
**Vendor Name**: CPrime
**URL**: [Course Link](https://www.fastlaneus.com/course/cprime-tddws)

## Objective
- Provide knowledge and understanding of Unit Testing principles and practices
- Understand the role of Unit Testing in software development and testing
- Write effective Unit Testing
- Properties of effective unit tests
- How to use mock objects to isolate the “system under test”
- Effective refactoring of the code base
- Benefits of the test-first and Test-Driven Development
- Techniques and practices to aid in the successful adoption of Test-Driven Development
- How to use Acceptance Testing and Behavior-Driven Development to further advance Test-Driven Development

## Essentials
Although it is not mandatory, students who have completed the self-paced Agile Testing eLearning course have found it very helpful when completing this course.

## Audience
This class is designed for professionals who have experience in language programming, including C+ or Java. Specific titles of attendees include:


- Software Developers and Programmers
- Agile Practitioners
- Quality Assurance Professionals
- Software Testers
- Product Owners
- Project Managers
- IT Managers
- Software Engineers

## Outline
Part 1: Agile Overview
Test Driven Development is a key component of the Agile Software Development Methodology and of the overall DevOps movement. So it is helpful to have at a minimum a high-level understanding of Agile practices and scrum ceremonies and TDD fits into the overall Agile, Scrum and DevOps landscape. Part 1 serves as a leveling exercise to ensure that team member is speaking the same language during upcoming labs and discussions.

What is Agile Software Development



- DevOps Overview
- The Agile Manifesto
- Scrum vs Agile
Components of Agile



- User Stories
- Tasks
- Bugs
- Automated Builds
- Automated Tests
- Continuous Inspection
The Role of TDD in Agile Development



- Automated Unit Tests
- Automated Acceptance Tests
Lab: Explore the Board of an Agile Project


- Kanban Board
- User Stories
- Tasks
- Bugs
- Work in Progress
- Burndown Chart
Part 2: Unit Testing
Unit Testing is a critical component of Test Driven Development (TDD). Small units of code are tested throughout the development process, which isolates functionality to ensure that individual parts work correctly.

Unit Test Fundamentals



- Reason to do Unit Testing
- What to Test: Right BICEP
- CORRECT Boundary Conditions
- Properties of Good Tests
Frameworks



- What is JUnit
- JUnit Building Blocks
- Test Cases
- Test Suites
- Examples
Agile Testing Strategy



- Agile Testing Quadrant
- Automation Pyramid
- Assertions
Test Attributes



- Setup / TearDown
- JUnit Lifecycle
- System Under Test
- Test Design Strategy
- Naming our Tests
- Exceptions
Lab: Introduction to Unit Testing


- IDE and Project Setup
- Running our first Unit Test
- Explore Junit framework
- Test Attributes
- Assert Statements


Part 3: Test Driven Development
Essential TDD techniques require developers write programs in short development cycles, and there are critical steps that must be taken. Tests are created before the code is written. Once the code passes testing, it is refactored to adhere to the most effective and acceptable standards.

TDD Rhythm



- TDD Overview
- Red, Green, Refactor
- TDD Benefits
Sustainable TDD



- Development without TD
- Test Last
- Test Last in Parallel
- Test Driven Development
Supporting Practices



- Collective Ownership
- Continuous Integration
Eight Wastes of Software Development



- Ripple effect of defects
- Partially Done Work
- Extra Features
- Relearning
- Handoffs
- Task Switching
- Delays
- Defects
Test Automation



- Automate, Automate, Automate
- Automate Early and Often
- Additional Topics Identified
Lab: Test Driven Development


- Start Test Driven Development on our example App
- Write unit test cases
- Experience RED, Green, Refactor Process
Part 4: Principles of Agile Development
TDD is directly influenced by design, so it will be a priority to take this into context during implementation. Considering design principles will enable teams to experiment with different approaches, and gear towards more functional programming.

Design Principles Overview
Coding Principles
isolation of the SUT
Developing independently testable units
Test doubles



- Introducing test doubles
- Stubs
- Fakes
- Mocks
Lab: Continue development on example App


- Setting up Test doubles for our example app
- Discuss and implement test dummy and test stubs
Part 5: Refactoring
Refactoring is another essential technique of TDD, and most software development teams are most likely doing some form of refactoring regularly. Refactoring can be used in a number of different workflows which will be explored in this Part.

Why Refactor?



- Red, Green, Refactor
- Benefits
- Development without TDD
Refactoring Methods
Refactoring Cycle



- Reduce Local Variable Scope
- Replace Temp with Query
- Remove Dead Code
- Extract Method
- Remove Unnecessary Code
Lab: Continue our example project


- Implement new test cases
- TDD Cycle
- Discuss and implement Refactoring Needs
Part 6: Pair Programming
Pair Programming is an effective way to improve code quality. In this Part, we will discuss pairing and how it leads to better software design, and a lower cost of development.

Pair Programming



- Pairing Setup
- Results: Time
- Results: Defects
- How it works
Advantages of Pairing



- Both Halves of the Brain
- Focus
- Reduce Interruptions
- Reduce Resource Constraints
- Multiple Monitors
- Challenges
Pairing Techniques



- Pair Rotation
- Ping Pong Pairing
- Promiscuous Pairs
- Pair Stairs
- Cross-Functional Pairing
Lab- Experience pair programming and continue developing our example app

Part 7: Acceptance Test Driven Development (ATDD) & Behavior-Driven Development (BDD)
Acceptance Tests are an important form of functional specification, and Behavior Driven Development dictates what happens as an effect of these tests being run. In this Part, we will cover the difference between them, and how they are closely related.

Acceptance Testing



- Acceptance Tests
- Why Acceptance Tests?
- Acceptance Test Execution
- Who Writes Acceptance Tests
- Pair Test Writing
Best Practices for Effective Testing



- Keys to Good Acceptance Tests
- Writing Acceptance Criteria
- Acceptance Test Example
- Acceptance Test-Driven Development (ATDD)
BDD vs. ATDD



- Specification by Example
- BDD Frameworks
- BDD Examples
Lab: Experience ATDD and BDD


- Experience ATDD or BDD and discuss the impact to TDD
Part 8: Advanced TDD
In order to implement Unit Tests efficiently, it is critical that developers understand their properties.

Lab: Demonstration for Mocking/doubles with our example App

TDD Solutions



- Continuous Unit Testing
- Collective Ownership
Advanced Unit Testing



- Unit Testing Legacy Applications
- Techniques for Legacy Code
- External Dependencies
- Mocking frameworks
- Unit Testing the Database
Outside In vs Inside Out



- Working with database
- Working with mocking frameworks
Test Strategy



- Continues Integration
- Batch Execution of TestCases
Unit Test Examples



- More Tests
- Algorithm
Advanced Refactoring
Lab: Demonstration for Mocking/doubles with our example App


- Working with database
- Working with mocking frameworks
Part 9: Simulation
Experience Agile development with test driven development and pair programming

## Summary
nan

## Course Duration
3 days

## Last Changed
2024-08-23T16:23:42.000Z
